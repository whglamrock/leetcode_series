from typing import List

# See union find: https://leetcode.com/problems/minimize-malware-spread/solutions/181129/c-python-union-found/
# O(N^2) BFS solution should suffice interview requirement.
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        connectedGroups = []
        for node in initial:
            if graph[node][node] == 0:
                continue
            connected = self.bfsConnectedNodes(graph, node)
            connectedGroups.append(connected)

        connectedGroups.sort(key=lambda x: -len(x))
        initial = set(initial)
        maxGroupSize = 0
        ans = None
        for connected in connectedGroups:
            connectedInitials = connected.intersection(initial)
            if len(connectedInitials) != 1:
                continue
            if len(connected) < maxGroupSize and ans is not None:
                break

            candidate = list(connectedInitials)[0]
            if len(connected) > maxGroupSize or ans is None:
                ans = candidate
                maxGroupSize = len(connected)
            # len(connected) == maxGroupSize
            else:
                ans = min(ans, candidate)

        # it's possible that no matter which node you remove it will result in the same number of final infection
        return ans if ans is not None else min(initial)

    def bfsConnectedNodes(self, graph: List[List[int]], start: int) -> set:
        n = len(graph)
        connected = set()
        todo = {start}
        while todo:
            nextTodo = set()
            for node in todo:
                connected.add(node)
                graph[node][node] = 0
                for connectedNode in range(n):
                    if graph[node][connectedNode] == 0 or connectedNode in connected:
                        continue
                    graph[node][connectedNode] = 0
                    graph[connectedNode][node] = 0
                    nextTodo.add(connectedNode)
            todo = nextTodo

        return connected


print(Solution().minMalwareSpread(graph=[[1, 1, 1], [1, 1, 1], [1, 1, 1]], initial=[1, 2]))
